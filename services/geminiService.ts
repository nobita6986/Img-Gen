import { GoogleGenAI, Modality } from '@google/genai';

/**
 * Converts a File object to a base64 encoded string.
 */
const fileToBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      if (typeof reader.result === 'string') {
        // result is "data:mime/type;base64,..." - we want only the part after the comma
        resolve(reader.result.split(',')[1]);
      } else {
        reject(new Error('Failed to read file as base64 string.'));
      }
    };
    reader.onerror = (error) => reject(error);
    reader.readAsDataURL(file);
  });
};

const handleApiError = (error: unknown): Error => {
    console.error('Error calling Gemini API:', error);
    
    let detailedMessage = 'An unknown error occurred.';
    let isRateLimitError = false;

    if (error instanceof Error) {
        detailedMessage = error.message;

        // Check for rate limit indicators
        if (error.message.includes('429') || error.message.includes('quota') || error.message.includes('RESOURCE_EXHAUSTED')) {
            isRateLimitError = true;
        }

        // Attempt to parse a more user-friendly message from JSON embedded in the error string
        const jsonMatch = error.message.match(/\{.*\}/);
        if (jsonMatch) {
            try {
                const errorJson = JSON.parse(jsonMatch[0]);
                if (errorJson.error?.message) {
                   detailedMessage = errorJson.error.message;
                }
            } catch (e) { /* Ignore parsing error */ }
        }
    }
    
    // Handle specific, non-retryable errors first
    if (detailedMessage.includes('API key not valid') || (error instanceof Error && error.message.includes('400 Bad Request'))) {
         return new Error('API key not valid. Please check your key.');
    }

    // If it's a rate limit error, throw it with a special prefix for the UI to handle retries
    if (isRateLimitError) {
        return new Error(`RATE_LIMIT: ${detailedMessage}`);
    }

    // For all other errors, throw the cleaned-up message
    return new Error(detailedMessage);
}

/**
 * Generates an image by editing a reference image with a text prompt.
 * Uses the 'gemini-2.5-flash-image' model.
 *
 * @param apiKey The Gemini API key.
 * @param referenceImageFile The original image file to be edited.
 * @param prompt The text prompt describing the desired edit.
 * @returns A base64 encoded string of the generated image.
 */
export const generateImageFromReference = async (
  apiKey: string,
  referenceImageFile: File,
  prompt: string
): Promise<string> => {
  if (!apiKey) {
    throw new Error('API key is missing.');
  }

  const ai = new GoogleGenAI({ apiKey });
  const base64ImageData = await fileToBase64(referenceImageFile);

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: [
          {
            inlineData: {
              data: base64ImageData,
              mimeType: referenceImageFile.type,
            },
          },
          {
            text: prompt,
          },
        ],
      },
      config: {
        responseModalities: [Modality.IMAGE],
      },
    });

    for (const part of response.candidates[0].content.parts) {
      if (part.inlineData) {
        return part.inlineData.data; // Return the first image found
      }
    }

    throw new Error('No image was generated. The model may have returned only text.');

  } catch (error) {
    throw handleApiError(error);
  }
};

/**
 * Generates an image from a text prompt using 'gemini-2.5-flash-image' as a fallback.
 */
const generateImageWithNanoBananaFromText = async (
  apiKey: string,
  prompt: string
): Promise<string> => {
  const ai = new GoogleGenAI({ apiKey });
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: [{ text: prompt }],
      },
      config: {
        responseModalities: [Modality.IMAGE],
      },
    });

    for (const part of response.candidates[0].content.parts) {
      if (part.inlineData) {
        return part.inlineData.data;
      }
    }
    throw new Error('Fallback generation failed: No image was generated by Nano Banana.');
  } catch (error) {
    throw handleApiError(error);
  }
};


/**
 * Generates an image from a text prompt using the 'imagen-4.0-generate-001' model.
 * If it encounters a rate limit, quota, or billing error, it automatically falls back to
 * 'gemini-2.5-flash-image'.
 *
 * @param apiKey The Gemini API key.
 * @param prompt The text prompt describing the desired image.
 * @param aspectRatio The desired aspect ratio for the image (only for Imagen).
 * @returns A base64 encoded string of the generated image.
 */
export const generateImageFromText = async (
  apiKey: string,
  prompt: string,
  aspectRatio: '1:1' | '16:9' | '9:16' | '4:3' | '3:4'
): Promise<string> => {
  if (!apiKey) {
    throw new Error('API key is missing.');
  }

  const ai = new GoogleGenAI({ apiKey });

  try {
    // First attempt with Imagen
    const response = await ai.models.generateImages({
        model: 'imagen-4.0-generate-001',
        prompt: prompt,
        config: {
          numberOfImages: 1,
          outputMimeType: 'image/jpeg',
          aspectRatio: aspectRatio,
        },
    });

    if (response.generatedImages && response.generatedImages.length > 0) {
        return response.generatedImages[0].image.imageBytes;
    }

    throw new Error('No image was generated by Imagen.');

  } catch (error) {
    // Check if the error is a quota/rate limit/billing error
    if (error instanceof Error && (
        error.message.includes('429') || 
        error.message.includes('quota') || 
        error.message.includes('RESOURCE_EXHAUSTED') ||
        error.message.includes('billed users at this time')
    )) {
        console.warn('Imagen failed (quota/billing/rate limit). Falling back to gemini-2.5-flash-image (Nano Banana).');
        // If it is, try the fallback model
        try {
            return await generateImageWithNanoBananaFromText(apiKey, prompt);
        } catch (fallbackError) {
             // If the fallback also fails, throw that error.
             throw handleApiError(fallbackError);
        }
    }
    
    // If it's not a rate limit error, handle it normally.
    throw handleApiError(error);
  }
};